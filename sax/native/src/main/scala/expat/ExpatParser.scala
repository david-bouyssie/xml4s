/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package expat

import java.io.{IOException, InputStream, Reader}
import java.net.{URI, URL}

import scala.scalanative.unsafe._

import libcore.io.IoUtils
import org.xml.sax._

import Expat._

/**
 * Adapts SAX API to the Expat native XML parser. Not intended for reuse
 * across documents.
 *
 * @see ExpatReader
 */
object ExpatParser {

  private val BUFFER_SIZE = 8096 // in bytes
  private val OUTSIDE_START_ELEMENT = "Attributes can only be used within the scope of startElement()."
  /** We default to UTF-8 when the user doesn't specify an encoding. */
  private val DEFAULT_ENCODING = "UTF-8"
  /** Encoding used for Java chars, used to parse Readers and Strings */
  private[expat] val CHARACTER_ENCODING = "UTF-16"
  /** Timeout for HTTP connections (in ms) */
  private[expat] val TIMEOUT = 20 * 1000

  // TODO: decide to keep or not (should be only useful for JNI)
  //staticInitialize("")

  /**
   * Creates a native entity parser.
   *
   * @param parentPointer pointer to parent Expat parser
   * @param context       passed to {@link #handleExternalEntity}
   * @return pointer to native parser
   */
  private def createEntityParser(parentPointer: XML_Parser, context: String): XML_Parser = {
    ExpatWrapper.createEntityParser(parentPointer, context)
  }

  /**
   * Initialize static resources.
   */
  // FIXME: native methods
  // TODO: call ExpatWrapper.staticInitialize?
  //private def staticInitialize(emptyString: String)

  private def line(pointer: XML_Parser): Int = ExpatWrapper.line(pointer)

  private def column(pointer: XML_Parser): Int = ExpatWrapper.column(pointer)

  private def cloneAttributes(pointer: Ptr[CString], attributeCount: Int): Ptr[CString] = {
    ExpatWrapper.Attributes.cloneAttributes(pointer, attributeCount)
  }

  /**
   * Used for cloned attributes.
   */
  private object ClonedAttributes {
    val EMPTY = new ExpatParser.ClonedAttributes(null, null, 0)
  }

  /**
   * Constructs a Java wrapper for native attributes.
   *
   * @param parserPointer pointer to the parse, can be 0 if length is 0.
   * @param pointer       pointer to the attributes array, can be 0 if the
   *                      length is 0.
   * @param length        number of attributes
   */
  private class ClonedAttributes private[ExpatParser](val parserPointer: XML_Parser, var pointer: Ptr[CString], val length: Int) extends ExpatAttributes {

    override def getParserPointer(): XML_Parser = parserPointer

    override def getPointer(): Ptr[CString] = pointer

    override def getLength(): Int = length

    // FIXME: SN has no finalize() implementation
    @throws[Throwable]
    override protected def finalize(): Unit = {
      try if (pointer != null) {
        ExpatWrapper.Attributes.freeAttributes(pointer)
        pointer = null
      }
      finally super.finalize()
    }
  }

  /**
   * Includes line and column in the message.
   */
  private object ParseException {
    private def makeMessage(message: String, locator: Locator): String = {
      makeMessage(message, locator.getLineNumber(), locator.getColumnNumber())
    }

    private def makeMessage(message: String, line: Int, column: Int) = {
      s"At line $line, column $column: $message"
    }
  }

  private class ParseException(private val message: String, private val locator: Locator, private val cause: Exception = null)
    extends SAXParseException(ParseException.makeMessage(message, locator), locator, cause)

  /**
   * Parses an external entity.
   */
  private class EntityParser private[ExpatParser](
    val encoding: String,
    val xmlReader: ExpatReader,
    val pointer: XML_Parser,
    val publicId: String,
    val systemId: String
  ) extends ExpatParser(encoding, xmlReader, pointer, publicId, systemId) {

    private var depth = 0

    @throws[SAXException]
    override private[expat] def startElement(uri: String, localName: String, qName: String, attributePointer: Ptr[CString], attributeCount: Int): Unit = {
      /*
       * Skip topmost element generated by our workaround in {@link #handleExternalEntity}.
       */
      depth += 1

      if (depth - 1 > 0)
        super.startElement(uri, localName, qName, attributePointer, attributeCount)
    }

    @throws[SAXException]
    override private[expat] def endElement(uri: String, localName: String, qName: String): Unit = {
      depth -= 1
      if (depth > 0)
        super.endElement(uri, localName, qName)
    }

    // FIXME: SN has no finalize() implementation
    @SuppressWarnings(Array("FinalizeDoesntCallSuperFinalize"))
    @throws[Throwable]
    override protected def finalize(): Unit = {
      /*
       * Don't release our native resources. We do so explicitly in
       * {@link #handleExternalEntity} and we don't want to release the
       * parsing context--our parent is using it.
       */
    }
  }

}

class ExpatParser {

  /** Pointer to XML_Parser instance. */
  // A few native methods taking the pointer value are static;
  // @ReachabilitySensitive is necessary to ensure the Java object is kept reachable sufficiently long in these cases.
  private var pointer: XML_Parser = _
  private var inStartElement = false
  private var attributeCount = -1
  private var attributePointer: Ptr[CString] = _

  final private val locator = new ExpatLocator()
  final private var xmlReader: ExpatReader = _
  final private var publicId: String = _
  final private var systemId: String = _
  final private var encoding: String = _
  final private val attributes: ExpatAttributes = new CurrentAttributes()

  /**
   * Constructs a new parser with the specified encoding.
   */
  def this(encoding: String, xmlReader: ExpatReader, processNamespaces: Boolean, publicId: String, systemId: String) = {
    this()
    this.publicId = publicId
    this.systemId = systemId
    this.xmlReader = xmlReader
    /*
     * TODO: Let Expat try to guess the encoding instead of defaulting.
     * Unfortunately, I don't know how to tell which encoding Expat picked,
     * so I won't know how to encode "<externalEntity>" below. The solution
     * I think is to fix Expat to not require the "<externalEntity>"
     * workaround.
     */
    this.encoding = if (encoding == null) ExpatParser.DEFAULT_ENCODING else encoding

    this.pointer = initialize(this.encoding, processNamespaces)
  }

  /**
   * Used by {@link EntityParser}.
   */
  private[ExpatParser] def this(encoding: String, xmlReader: ExpatReader, pointer: XML_Parser, publicId: String, systemId: String) = {
    this()
    this.encoding = encoding
    this.xmlReader = xmlReader
    this.pointer = pointer
    this.systemId = systemId
    this.publicId = publicId
  }

  /**
   * Initializes native resources.
   *
   * @return the pointer to the native parser
   */
  private def initialize(encoding: String, namespacesEnabled: Boolean): XML_Parser = {
    ExpatWrapper.initializeParser(this, encoding, namespacesEnabled)
  }

  /**
   * Called at the start of an element.
   *
   * @param uri              namespace URI of element or "" if namespace processing is
   *                         disabled
   * @param localName        local name of element or "" if namespace processing is
   *                         disabled
   * @param qName            qualified name or "" if namespace processing is enabled
   * @param attributePointer pointer to native attribute char*--we keep
   *                         a separate pointer so we can detach it from the parser instance
   * @param attributeCount   number of attributes
   */
  @throws[SAXException]
  private[expat] def startElement(uri: String, localName: String, qName: String, attributePointer: Ptr[CString], attributeCount: Int): Unit = {

    val contentHandler = xmlReader.contentHandler
    if (contentHandler == null) return
    try {
      inStartElement = true
      this.attributePointer = attributePointer
      this.attributeCount = attributeCount
      contentHandler.startElement(uri, localName, qName, this.attributes)
    } finally {
      inStartElement = false
      this.attributeCount = -1
      this.attributePointer = null
    }
  }

  @throws[SAXException]
  private[expat] def endElement(uri: String, localName: String, qName: String): Unit = {
    val contentHandler = xmlReader.contentHandler
    if (contentHandler != null) contentHandler.endElement(uri, localName, qName)
  }

  @throws[SAXException]
  private[expat] def text(text: Array[Char], length: Int): Unit = {
    val contentHandler = xmlReader.contentHandler
    if (contentHandler != null) contentHandler.characters(text, 0, length)
  }

  @throws[SAXException]
  private[expat] def comment(text: Array[Char], length: Int): Unit = {
    val lexicalHandler = xmlReader.lexicalHandler
    if (lexicalHandler != null) lexicalHandler.comment(text, 0, length)
  }

  @throws[SAXException]
  private[expat] def startCdata(): Unit = {
    val lexicalHandler = xmlReader.lexicalHandler
    if (lexicalHandler != null) lexicalHandler.startCDATA()
  }

  @throws[SAXException]
  private[expat] def endCdata(): Unit = {
    val lexicalHandler = xmlReader.lexicalHandler
    if (lexicalHandler != null) lexicalHandler.endCDATA()
  }

  @throws[SAXException]
  private[expat] def startNamespace(prefix: String, uri: String): Unit = {
    val contentHandler = xmlReader.contentHandler
    if (contentHandler != null) contentHandler.startPrefixMapping(prefix, uri)
  }

  @throws[SAXException]
  private[expat] def endNamespace(prefix: String): Unit = {
    val contentHandler = xmlReader.contentHandler
    if (contentHandler != null) contentHandler.endPrefixMapping(prefix)
  }

  @throws[SAXException]
  private[expat] def startDtd(name: String, publicId: String, systemId: String): Unit = {
    val lexicalHandler = xmlReader.lexicalHandler
    if (lexicalHandler != null) lexicalHandler.startDTD(name, publicId, systemId)
  }

  @throws[SAXException]
  private[expat] def endDtd(): Unit = {
    val lexicalHandler = xmlReader.lexicalHandler
    if (lexicalHandler != null) lexicalHandler.endDTD()
  }

  @throws[SAXException]
  private[expat] def processingInstruction(target: String, data: String): Unit = {
    val contentHandler = xmlReader.contentHandler
    if (contentHandler != null) contentHandler.processingInstruction(target, data)
  }

  @throws[SAXException]
  private[expat] def notationDecl(name: String, publicId: String, systemId: String): Unit = {
    val dtdHandler = xmlReader.dtdHandler
    if (dtdHandler != null) dtdHandler.notationDecl(name, publicId, systemId)
  }

  @throws[SAXException]
  private[expat] def unparsedEntityDecl(name: String, publicId: String, systemId: String, notationName: String): Unit = {
    val dtdHandler = xmlReader.dtdHandler
    if (dtdHandler != null) dtdHandler.unparsedEntityDecl(name, publicId, systemId, notationName)
  }

  /**
   * Handles an external entity.
   *
   * @param context  to be passed back to Expat when we parse the entity
   * @param publicId the publicId of the entity
   * @param systemId the systemId of the entity
   */
  @throws[SAXException]
  @throws[IOException]
  private[expat] def handleExternalEntity(context: String, publicId: String, systemId: String): Unit = {
    val entityResolver = xmlReader.entityResolver
    if (entityResolver == null) return

    /*
     * The spec. is terribly under-specified here. It says that if the
     * systemId is a URL, we should try to resolve it, but it doesn't
     * specify how to tell whether or not the systemId is a URL let alone
     * how to resolve it.
     *
     * Other implementations do various dangerous things. We try to keep it
     * simple: if the systemId parses as a URI and it's relative, we try to
     * resolve it against the parent document's systemId. If anything goes
     * wrong, we go with the original systemId. If crazybob had designed
     * the API, he would have left all resolving to the EntityResolver.
     */
    val parsedSystemId: String = if (this.systemId == null) null
    else {
      try {
        var systemUri = new URI(systemId)
        if (!systemUri.isAbsolute && !systemUri.isOpaque) {
          // It could be relative (or it may not be a URI at all!)
          val baseUri = new URI(this.systemId)
          systemUri = baseUri.resolve(systemUri)

          // Replace systemId w/ resolved URI
          systemUri.toString
        } else systemId
      } catch {
        case e: Exception =>
          // TODO: use a logger.error instead
          println(s"ExpatParser: Could not resolve '$systemId' relative to '${this.systemId}' at $locator", e)
          systemId
      }
    }

    val inputSource = entityResolver.resolveEntity(publicId, parsedSystemId)
    if (inputSource == null) {
      /*
       * The spec. actually says that we should try to treat systemId
       * as a URL and download and parse its contents here, but an
       * entity resolver can easily accomplish the same by returning
       * new InputSource(systemId).
       *
       * Downloading external entities by default would result in several
       * unwanted DTD downloads, not to mention pose a security risk
       * when parsing untrusted XML -- see for example
       * http://archive.cert.uni-stuttgart.de/bugtraq/2002/10/msg00421.html --
       * so we just do nothing instead. This also enables the user to
       * opt out of entity parsing when using
       * {@link org.xml.sax.helpers.DefaultHandler}, something that
       * wouldn't be possible otherwise.
       */
      return
    }

    val encoding = pickEncoding(inputSource)
    val pointer = ExpatParser.createEntityParser(this.pointer, context)

    try {
      val entityParser = new ExpatParser.EntityParser(encoding, xmlReader, pointer, inputSource.getPublicId(), inputSource.getSystemId())
      parseExternalEntity(entityParser, inputSource)
    } finally {
      releaseParser(pointer)
    }
  }

  /**
   * Picks an encoding for an external entity. Defaults to UTF-8.
   */
  private def pickEncoding(inputSource: InputSource): String = {
    val reader = inputSource.getCharacterStream()
    if (reader != null) return ExpatParser.CHARACTER_ENCODING
    val encoding = inputSource.getEncoding()
    if (encoding == null) ExpatParser.DEFAULT_ENCODING
    else encoding
  }

  /**
   * Parses the the external entity provided by the input source.
   */
  @throws[IOException]
  @throws[SAXException]
  private def parseExternalEntity(entityParser: ExpatParser, inputSource: InputSource): Unit = {
    /*
     * Expat complains if the external entity isn't wrapped with a root
     * element so we add one and ignore it later on during parsing.
     */

    // Try the character stream.
    val reader = inputSource.getCharacterStream()
    if (reader != null) {
      try {
        entityParser.append("<externalEntity>")
        entityParser.parseFragment(reader)
        entityParser.append("</externalEntity>")
      } finally IoUtils.closeQuietly(reader)
      return
    }

    // Try the byte stream.
    var in = inputSource.getByteStream()
    if (in != null) {
      try {
        entityParser.append("<externalEntity>".getBytes(entityParser.encoding))
        entityParser.parseFragment(in)
        entityParser.append("</externalEntity>".getBytes(entityParser.encoding))
      } finally IoUtils.closeQuietly(in)
      return
    }

    // Make sure we use the user-provided systemId.
    val systemId = inputSource.getSystemId()
    if (systemId == null) { // TODO: We could just try our systemId here.
      throw new ExpatParser.ParseException("No input specified.", locator)
    }

    // Try the system id.
    in = IoUtils.openUrl(systemId, ExpatParser.TIMEOUT)
    try {
      entityParser.append("<externalEntity>".getBytes(entityParser.encoding))
      entityParser.parseFragment(in)
      entityParser.append("</externalEntity>".getBytes(entityParser.encoding))
    } finally IoUtils.closeQuietly(in)
  }

  /**
   * Appends part of an XML document. This parser will parse the given XML to
   * the extent possible and dispatch to the appropriate methods.
   *
   * @param xml a whole or partial snippet of XML
   * @throws SAXException if an error occurs during parsing
   */
  @throws[SAXException]
  private[expat] def append(xml: String): Unit = {
    try appendString(this.pointer, xml, false)
    catch {
      case e: ExpatException => {
        val cause = e.getCause
        if (cause != null) {
          throw new ExpatParser.ParseException(e.getMessage, this.locator, cause.asInstanceOf[Exception])
        } else {
          throw new ExpatParser.ParseException(e.getMessage, this.locator)
        }
      }
    }
  }

  @throws[SAXException]
  @throws[ExpatException]
  private def appendString(pointer: XML_Parser, xml: String, isFinal: Boolean): Unit = {
    ExpatWrapper.appendString(this, pointer, xml, isFinal)
  }

  /**
   * Appends part of an XML document. This parser will parse the given XML to
   * the extent possible and dispatch to the appropriate methods.
   *
   * @param xml    a whole or partial snippet of XML
   * @param offset into the char[]
   * @param length of characters to use
   * @throws SAXException if an error occurs during parsing
   */
  @throws[SAXException]
  private[expat] def append(xml: Array[Char], offset: Int, length: Int): Unit = {
    try appendChars(this.pointer, xml, offset, length)
    catch {
      case e: ExpatException =>
        throw new ExpatParser.ParseException(e.getMessage, this.locator)
    }
  }

  @throws[SAXException]
  @throws[ExpatException]
  private def appendChars(pointer: XML_Parser, xml: Array[Char], offset: Int, length: Int): Unit = {
    ExpatWrapper.appendChars(this, pointer, xml, offset, length)
  }

  @throws[SAXException]
  private[expat] def append(xml: Array[Byte]): Unit = append(xml, 0, xml.length)

  /**
   * Appends part of an XML document. This parser will parse the given XML to
   * the extent possible and dispatch to the appropriate methods.
   *
   * @param xml    a whole or partial snippet of XML
   * @param offset into the byte[]
   * @param length of bytes to use
   * @throws SAXException if an error occurs during parsing
   */
  @throws[SAXException]
  private[expat] def append(xml: Array[Byte], offset: Int, length: Int): Unit = {
    try appendBytes(this.pointer, xml, offset, length)
    catch {
      case e: ExpatException =>
        throw new ExpatParser.ParseException(e.getMessage, this.locator)
    }
  }

  @throws[SAXException]
  @throws[ExpatException]
  private def appendBytes(pointer: XML_Parser, xml: Array[Byte], offset: Int, length: Int): Unit = {
    ExpatWrapper.appendBytes(this, pointer, xml, offset, length)
  }

  /**
   * Parses an XML document from the given input stream.
   */
  @throws[IOException]
  @throws[SAXException]
  private[expat] def parseDocument(in: InputStream): Unit = {
    startDocument()
    parseFragment(in)
    finish()
    endDocument()
  }

  /**
   * Parses an XML Document from the given reader.
   */
  @throws[IOException]
  @throws[SAXException]
  private[expat] def parseDocument(in: Reader): Unit = {
    startDocument()
    parseFragment(in)
    finish()
    endDocument()
  }

  /**
   * Parses XML from the given Reader.
   */
  @throws[IOException]
  @throws[SAXException]
  private def parseFragment(in: Reader): Unit = {
    val buffer = new Array[Char](ExpatParser.BUFFER_SIZE / 2)
    var length = 0
    while ({length = in.read(buffer); length != -1}) {
      try appendChars(this.pointer, buffer, 0, length)
      catch {
        case e: ExpatException =>
          throw new ExpatParser.ParseException(e.getMessage, locator)
      }
    }
  }

  /**
   * Parses XML from the given input stream.
   */
  @throws[IOException]
  @throws[SAXException]
  private def parseFragment(in: InputStream): Unit = {
    val buffer = new Array[Byte](ExpatParser.BUFFER_SIZE)
    var length = 0
    while ( {length = in.read(buffer); length != -1}) {
      try appendBytes(this.pointer, buffer, 0, length)
      catch {
        case e: ExpatException =>
          throw new ExpatParser.ParseException(e.getMessage, this.locator)
      }
    }
  }

  @throws[SAXException]
  private def startDocument(): Unit = {
    val contentHandler = xmlReader.contentHandler
    if (contentHandler != null) {
      contentHandler.setDocumentLocator(this.locator)
      contentHandler.startDocument()
    }
  }

  @throws[SAXException]
  private def endDocument(): Unit = {
    if (xmlReader.contentHandler != null)
      xmlReader.contentHandler.endDocument()
  }

  /**
   * Indicate that we're finished parsing.
   *
   * @throws SAXException if the xml is incomplete
   */
  @throws[SAXException]
  private[expat] def finish(): Unit = {
    try appendString(this.pointer, "", true)
    catch {
      case e: ExpatException =>
        throw new ExpatParser.ParseException(e.getMessage, this.locator)
    }
  }

  @throws[Throwable]
  // FIXME: SN has no finalize() implementation
  override protected def finalize(): Unit = {
    try if (this.pointer != null) {
      release(this.pointer)
      this.pointer = null
    }
    finally {
      super.finalize()
    }
  }

  /**
   * Releases all native objects (ParsingContext + XML_Parser).
   */
  private def release(pointer: XML_Parser): Unit = {
    ExpatWrapper.release(pointer)
  }

  /**
   * Releases native parser only.
   */
  private def releaseParser(pointer: XML_Parser): Unit = {
    ExpatWrapper.releaseParser(pointer)
  }

  /**
   * Gets the current line number within the XML file.
   */
  private def line(): Int = ExpatParser.line(this.pointer)

  /**
   * Gets the current column number within the XML file.
   */
  private def column(): Int = ExpatParser.column(this.pointer)

  /**
   * Clones the current attributes so they can be used outside of startElement().
   */
  private[expat] def cloneAttributes(): Attributes = {
    if (!inStartElement)
      throw new IllegalStateException(ExpatParser.OUTSIDE_START_ELEMENT)

    if (attributeCount == 0)
      return ExpatParser.ClonedAttributes.EMPTY

    val clonePointer = ExpatParser.cloneAttributes(this.attributePointer, this.attributeCount)
    new ExpatParser.ClonedAttributes(pointer, clonePointer, attributeCount)
  }

  private class ExpatLocator extends Locator {
    override def getPublicId(): String = publicId

    override def getSystemId(): String = systemId

    override def getLineNumber(): Int = line()

    override def getColumnNumber(): Int = column()

    override def toString = {
      s"Locator[publicId: $publicId, systemId: $systemId, line: ${getLineNumber()}, column: ${getColumnNumber()}]"
    }
  }

  /**
   * Attributes that are only valid during startElement().
   */
  private class CurrentAttributes extends ExpatAttributes {

    override def getParserPointer(): XML_Parser = pointer

    override def getPointer(): Ptr[CString] = {
      if (!inStartElement) throw new IllegalStateException(ExpatParser.OUTSIDE_START_ELEMENT)
      attributePointer
    }

    override def getLength() = {
      if (!inStartElement) throw new IllegalStateException(ExpatParser.OUTSIDE_START_ELEMENT)
      attributeCount
    }
  }
}